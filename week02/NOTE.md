[TOC]

# week 2

## JS语言通识

### 泛用语言分类方法

**语言按语法分类：**

- 非形式语言：比较自由，没有固定形式，语法没有严格的定义，例如：中文、英文
- 形式语言：形式化定义，严格、严谨，**分类谱系：乔姆斯基谱系**

**乔姆斯基谱系分类：**

- 0型 无限制文法：只需定义清楚了语言是什么样的
- 1型 上下文相关文法：同样一个词、句的组合，可以跟上文、下文、以及它的内容相关
- 2型 上下文无关文法：同样的一个表达式，无论放到哪里都是一样的意思
- 3型 正则文法：有时候被翻译成正规文法，英文都是regular这个词，正则文法就是所有能够被正则表达式直接去描述的一种文法

**注意：乔姆斯基谱系分类中，0型 1型 2型 3型 是一种包含关系，一个上下文相关文法一定也属于0型，反过来就不一定了，2型和3型也一样，一个正则文法一定隶属于0型、1型和2型**

### 什么是产生式

**产生式：**

- 用尖括号括起来的名称来表示语法结构名
- 语法结构分成**基础结构**和需要用其他语法结构定义的**复合结构**
  - 基础结构称为终结符(Terminal Symbol)
  - 复合结构称为非终结符(Nonterminal Symbol)
- 引号和中间的字符表示终结符
- 可以有括号
- \* 表示重复多次
- | 表示或
- + 表示至少一次

### 深入理解产生式

**通过产生式理解乔姆斯基谱系：**

- 0型 无限制文法
  - ?::=?   无限制文法就是随便写，定义的左边和右边不管些什么东西都ok
- 1型 上下文相关文法
  - ?<A>==?==::=?<B>==?==   
  - **解析**：左边右边都可以写多个非终结符，但是变得只能有一个，变化的部分有一个上下文的关系，一定有一个固定不变的部分（前面问号和后面高亮问好部分就是不变的部分）
- 2型 上下文无关文法
  - <A>::=?   
  - **解析：**产生式左边只能有一个非终结符，右面可以随便写，可以是一大堆产生一个非终结符，也可以是终结符和非终结符的混合。
- 3型 正则文法
  - <A>::=<A>?    
  - ~~<A>::=?<A>~~
  - **解析：**加入正则文法是递归定义的，那么它不允许这个定义A出现在尾巴上，比如左边是一个符号A，那么右边A一定是出现在产生式的最开头，根据这个规则，所有的正则文法都可以被用正则表达式来表示。

### 现代语言的分类

**现代语言的特例：**

- C++中，* 可能表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型
- VB中，< 可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接收XML直接量
- Python中，行首的tab符和空格会根据上一行的行首空白以一定规则被处理成虚拟终结符indent或者ddedent
- JavaScript中，/ 可能是除号，也可能是正则表达式开头，处理方式类似于VB，字符串模板中也需要特殊处理 } ，还有自动插入分号规则

**语言的分类：**

- 形式语言—用途

  - 数据描述语言

    > **例如：**JSON、HTML、XAML、SQL、CSS

  - 编程语言

    > **例如：**C、C++、Java、C#、Python、Ruby、Perl、Lisp、T-SQL、Clojure、Haskell、JavaScript

- 形式语言—表达方式

  - 声明式语言

    > **例如：**JSON、HTML、XAML、SQL、CSS、Lisp、Clojure、Haskell

  - 命令型语言

    > **例如：**C、C++、Java、C#、Python、Ruby、Perl、JavaScript

### 编程语言的性质

**图灵完备性：**所有的可计算的问题都可用来描述的，这样的语言就是具备图灵完备性的。

- 命令式—图灵机
  - goto
  - if和while
- 声明式—lambda
  - 递归

**动态与静态：**

- 动态：
  - 在用户的设备/在线服务器上
  - 产品实际运行时
  - Runtime（运行时）
- 静态：
  - 在程序员的设备上
  - 产品开发时
  - Compiletime（编译时）

**类型系统**

- 动态类型系统与静态类型系统
- 强类型与弱类型
  - String + Number
  - String == Boolean
- 复合类型
  - 结构体
  - 函数签名
- 子类型
- 泛型
  - 逆变/协变

### 一般命令式编程语言的设计方式

**一般命令式编程语言：**

- Atom（原子级）：一个语言的最小的组成单位
  - Identifier（标识符）
  - Literal（字面量）
- Expression（表达式）：原子级的这些结构通过运算符相连接，然后加上一些辅助的符号，就会构成一个表达式的结构，表达式通常是一个可以级联的结构（例如四则运算的产生式），复杂的语言可能有10多层的表达式。
  - Atom（原子级）
  - Operator（运算符）
  - Punctuator （辅助符号）
- Statement（语句）：表达式加上一些特定的标识符和一些特定的关键字和一些特定的符号形成一定的结构，把它叫做语句。例如：if-else语句、for循环语句、while循环语句等。一个有语句的语言已经是一个可以达成图灵完备并且去执行的语言了。
  - Expression（表达式）
  - Keyword（关键字）
  - Punctuator（辅助符号）
- Structure（结构化）：例如JavaScript中有Function、Class这样的一些设计，帮助我们组织代码，把代码分成不同的块，然后分成不同的复用的结构。
  - Function（函数）
  - Class（类）
  - Process（过程，JavaScript中没有）
  - Namespace
  - ......
  - Program（程序）：通常用来组织代码，有的语言有，有的不在语言里面在一些辅助性的设施里面，package、module、library能帮助我们更好的去管理语言的模块和安装，再JavaScript中来做这个角色的通常是npm。JavaScript本身也有两个最顶级的定义，一个叫program，一个叫module。module就是准备好被复用的模块，program就是实际执行的代码
  - Program
  - Module
  - Package
  - Library

## JavaScript类型

### Atom(原子级)

**Grammar(语法)**

- Literal（字面量）
- Variable （变量）
- Keywords （关键词）
- Whitespace （空白符）
- Line Terminator （换行符）

**Runtime(运行时)**

- Types （类型）
- Execution Context （ 执行上下文）

### Types

- Number
- String
- Boolean
- Object
- Null
- Undefined
- Symbol

### Number

 #### 定义

- **IEEE 754 标准中规定Number为64位Double Float（双精度浮点类型）**

- **Float：表示浮点数，意思是它的小数点是可以来回浮动的，基本思想就是把一个数字拆成它的指数和有效位数**

#### 双精度浮点类型的表示原理

- 十进制科学记数法：a * 10^b，其中  **1 <= a <= 10**，

  - **例：**十进制 322 用科学记数法表示为 **3.22 * 10^2**

- 二进制科学记数法：a * 2^b，其中 **a=1**

  - **例：**二进制 1001 用科学记数法表示为 **1.001 * 2^3** 

- IEEE 754标准中规定Number位64位双精度浮点类型，这64位的每一位为一个bit，取值为0或1

- 在这64位的表示中，具体分布如下：

  - **Sign(1)**：64位的第1位为符号位，1为负，0为正。符号位只表示正负，不参与具体数值的计算。
  - **Exponent(11)**：64位的第2位到第12位，共11位，表示指数位，对于11位的指数位来说，取值范围为0~2047，即 **0 ~ 2^11-1**，是一个无符号整数，在科学记数法中的指数可以为负数，所以约定一个中间数1023（二进制为01111111111），即0\~1022表示为负，1024~2047表示为正。所以用指数位减去中间数1023来表示二进制科学记数法的指数部分（如：二进制科学记数法：**a * 2^n**，指数位用来表示n的值）
  - **Fraction(52)**：64位的第13位到第64位，共52位，表示有效位数，用来表示二进制记数法：**a * 2^3** 中**a**的小数部分，（如：二进制科学记数法：1.001 * 2^3，有效位数用来表示1.001中的 001的部分）

- 除了上面的64位外，还有一个隐藏位，值为1，位于指数位和有效位数之间，不计入64位中。隐藏位表示的是二进制科学计数法：**a * 2^3**中**a**的整数部分，如：二进制记数法：**1.001 * 2^3**，隐藏位用来表示1.001中小数点前面的1。

- 设：符号位(Sign)为 **S**，指数位(Exponent)为**E**，有效位数(Fraction)为**F**，隐藏位为**H**。

  - 基于上述内容，浮点数(**V**)的表示方法公式为：**V = (-1)^S * 2^(E - 1023) * (1 + F)**

  - **例如：**

    - 十进制数字 2，用双精度浮点数表示的步骤：

      1. 把十进制转换成二进制，即 十进制 2 转换为 二进制结果是 10

      2. 把 二进制10 用二进制科学记数法表示为 1.0 * 2^1，从而可知道**符号位S = 0，指数为E-1023 = 1即E = 1024，F = 0，隐藏位 = 1**

      3. **S = 0 (1位)**

         **E = 1024 = 10000000000 (11位)**

         **F = 0 = 00000......000 (52位)**

         **H = 1 (不计入64位中)**

         因此64双精度浮点数表示为：

         0 10000000000 **1** 000000000000000000000000000000000000000000000000000

         0 （加粗的1为隐藏位）

#### Number— Grammar(语法)

**Number的语法在2018标准里分成了四个部分：**

- DecimalLiteral（十进制）
  - .0
  - 0.
  - .2
  - 1e3
- BinaryIntegerLiteral（二进制）
  - 0b111
- OctallntegerLiteral（八进制）
  - 0o10
- HexIntegerLiteral（十六进制）
  - 0xFF

**注意：由于 0. 是表示十进制的合法写法，所以 0.toString() 会报错，若想要不报错的话，**

**需要在0后面加上空格，即 0 .toString()**

### String

#### 总览

- Character (字符)
- Code Point (码点)  用来表示字符得数字
- Encoding (编码)  规定了码点在计算机中的表示方法

在计算机中是通过**Code Point(码点)**来存储**Character(字符)**的，**Code Point**简单说就是一个数字，例如97代表a，然后结合一定的类型信息就可以通过97和字体里面的信息把a找出来。对于**Code Point**的存储来说，由于计算机存储的基本单位是字节，**Code Point**的大小有可能超出一个字节，所以对于**Code Point**有一个**Encoding(编码方式)**，**Ecoding**规定了**Code Point**存储几个字节，字节里是一个什么格式。

#### 字符集

- ASCII：包含常用127个字符（其中包括26个大写字母、26个小写字母、数字0到9、各种制表符、特殊符号、换行等控制字符），使用0~127来表示，每个字符只占一个字节，由于ASCII字符集是最早美国计算机先发明的字符集，所以只照顾到了英文，无法表示中文。但是所有的编码集都会兼容ASCII

- Unicode：Unicode联合的编码集，汇集了全世界的各种字符的编码方式。Unicode的字符的数量非常大，还划成了各种的片区，一个片区一个片区的去分配，最终形成一个Unicode的庞大的编码集。Unicode共有17个片区，整个空间大小是2^21，Unicode的码点通常用U+???来表示，其中???是十六进制的码点值。

  0\~65536 (U+0000 - U+FFFF)的码点被称为基本字符区域（缩写BMP），所有最常见的字符都放在这个片区，这是Unicode最先定义和公布的一个片区，剩下的字符都放在辅助片区（缩写SMP，共16个辅助片区），码点范围 U+010000 - U+10FFFF

- UCS：Unicode与另一个标准化组织发生合并的时候，产生了一个叫UCS的这样的一个字符集，是0000~FFFF这个范围的字符集

- GB(国标版本)：国标编码有一个特点就是与Unicode的字符集的码点不一致，
  - GB2312：国标字符集的第一个版本，也是非常广泛使用的一个版本
  - GBK(GB13000)
  - GB18030
  
- ISO-8859: 与国标类似

- BIG5：大五码，台湾通常使用这种编码方式

#### 编码 Encoding

- UTF

  - UTF8: **UTF8是Unicode字符集得一种编码方式之一**，UTF8是一种变长字节编码方式，UTF8的编码方式与ASCII字符集中字符得编码方式是兼容的，也就是一段ASCII编码的文字，同时也一定是一个UTF-8编码的这样的一段文字，当然反过来是不成立的，因为UTF8默认使用一个字节进行编码，但是不是所有字符都可以用一个字节表示。

  - **编码规则如下：**

    1. 对于单字节的符号，字节的第一位设为`0`，后面7为为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。

    2. 对于`n`字节的符号（`n>1`），第一个字节的前`n`位都设为`1`，第`n+1`位设为`0`，后面字节的前两位一律设为`10`。

       | Unicode符号范围(十六进制) | UTF-8编码方式（二进制）             |
       | :------------------------ | :---------------------------------- |
       | 0000 0000 - 0000 007F     | 0xxxxxxx                            |
       | 0000 0080 - 0000 07FF     | 110xxxxx 10xxxxxx                   |
       | 0000 0800 - 0000 FFFF     | 1110xxxx 10xxxxxx 10xxxxxx          |
       | 0001 0000 - 0010 FFFF     | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

       **根据上表，如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。**

    3. **举例**：以汉字`一`为例，`一`的Unicode是`4E00`(二进制：100111000000000)，根据上表可知汉字`一`的码点，处在第三行的范围（0000 0800 - 0000 FFFF），所以使用UTF8对汉字`一`进行编码需要三个字节，格式为：`1110xxxx 10xxxxxx 10xxxxxx`，接下来从`一`的而进制（100111000000000）的最后一位开始依次从后向前填充x的位置，多出的位补0，最后得出汉字`一`的UTF8编码是`11100100 10111000 10000000`

  - UTF16：默认使用16个比特位也就是2个字节表示一个字符。

- 练习：写一段js代码，把一个string代表的字节转换出来，用UTF8对string进行编码：

  ```javascript
  var writeUTF = function (str, isGetBytes) {
        var back = [];
        var byteSize = 0;
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (0x00 <= code && code <= 0x7f) {
                  byteSize += 1;
                  back.push(code);
            } else if (0x80 <= code && code <= 0x7ff) {
                  byteSize += 2;
                  back.push((192 | (31 & (code >> 6))));
                  back.push((128 | (63 & code)))
            } else if ((0x800 <= code && code <= 0xd7ff) 
                    || (0xe000 <= code && code <= 0xffff)) {
                  byteSize += 3;
                  back.push((224 | (15 & (code >> 12))));
                  back.push((128 | (63 & (code >> 6))));
                  back.push((128 | (63 & code)))
            }
         }
         for (i = 0; i < back.length; i++) {
              back[i] &= 0xff;
         }
         if (isGetBytes) {
              return back
         }
         if (byteSize <= 0xff) {
              return [0, byteSize].concat(back);
         } else {
              return [byteSize >> 8, byteSize & 0xff].concat(back);
          }
  }
  
  writeUTF('中'); // =>  [0, 3, 228, 184, 173] 
  ```

#### String-Grammar

- "abc"
- 'abc'

> 早年的JavaScript中的字符串支持两种写法，分别是：**单引号写法**和**双引号写法**。这两种写法没有任何的区别，唯一的不同在于单双引号的使用下：
>
> - 双引号里面可以加单引号作为普通字符
> - 单引号里面可以加双引号作为普通字符
>
> 这两写法是完全等效的，这两种写法中会有一些特殊字符，比如无法使用回车，就规定了一个\n来表示；Tab是可以用的，但是还是规定了\t表示Tab符；双引号字符串中如果还想用双引号这个字符时需要在前面加个反斜杠，单引号字符串同理；在字符串中没有特殊含义的字母，前面加反斜杠都是它自身，比如 \a就是a；若想表示反斜杠自身的话需要在反斜杠前面再加一个反斜杠（也就是双反斜杠）。

- \`abc`

> 在比较新的JavaScript版本中，新增了一个字符串的表示方法，就是使用反引号的版本，在反引号字符串中，只要不使用反引号，加什么都可以（回车、tab......）,并且还可以用$符和花括号表示一个变量的结果

- \b、\f、\n、\r、\t、\v，记住这几个转义符号。还需要知道\x和\u的转义的规则

  | 转义字符 | 转义Unicode |    产生字符     |
  | :------: | :---------: | :-------------: |
  |    \b    |   U+0008    |    \<BS>退格    |
  |    \f    |   U+000C    |    \<FF>换页    |
  |    \n    |   U+000A    |    \<LF>换行    |
  |    \r    |   U+000D    |    \<CR>回车    |
  |    \t    |   U+0009    | \<HT>水平制表符 |
  |    \v    |   U+000B    | \<VT>垂直制表符 |

  | 转义字符 |                      含义                      |
  | :------: | :--------------------------------------------: |
  |    \x    | 十六进制，后面跟两个十六进制数，表示单字节编码 |
  |    \u    |       后面跟4个16进制数，表示Unicode字符       |

  

#### String-Grammar-Template(模板字符串语法 \`abc`)

**\`ab${x}abc${y}abc`**

> JavaScript引擎在解析上面这种模板字符串字面量的写法的时候，并不是直接计算出一个字符串，实际上是把这个字符串拆分成了如下结构：
>
> - `ab${
> - }abc${
> - }abc`
>
> 上面这三种结构再组合上大括号中间的JavaScript表达式构成一个完整的字符串。
>
> 实际上JavaScript引擎为了解析模板字符串，新生成了4组token，分别是：
>
> - **`** 和 **${**
> - **}** 和 **${**
> - **}** 和 **`**
> - **\`** 和 **`**
>
> 只有以上四种token种任意一组中间包含的才是真正的字符串，然后再组合JavaScript表达式，呈现出一个最终的字符串。注意：第四组token只有在模板字符串中没有${}时才生效。

### Boolean

- true
- false

### Null & Undefined

- null   表示有值，但是是空

- undefined   表示根本没有人去设过这个值，也就是没有定义，undefined是一个全局的变量，早期的JavaScript版本可以为它重新赋值，而现在仍然可以在函数里面局部地去定义Undefined为true：

  ```
  function f(){
  	var undefined = 1;
  	console.log(undefined);
  }
  f();// 1
  
  function f(){
  	var null = 0;
  	console.log(null);
  }
  f();// Uncaught SyntaxError: Unexpected token null
  ```

  

- void 0;   一般用void 0; 来产生undefined，因为void运算符是个关键字，void后面不管跟什么，都会变成undefined这个值，所以在语法上最简洁地得到undefined地值得方法就是使用这个void关键字来进行一次运算。

**注意：注意null是一个关键字，而undefined并不是一个关键字**

### Object

#### 概要

- 任何一个对象都是唯一的，这与它本身的状态无关。所以，即使状态完全一致的两个对象，也并不相等。
- 对象不是由状态决定的，而是状态由对象决定的
- **用状态来描述对象**
- **状态的改变即是行为**

#### 对象的组成

对象由三个核心要素组成：

- 唯一性的标识
- 状态
- 行为

#### Object — Class

**类**是一种常见的描述对象的方式。

而“归类”和“分类”则是两个主要的流派：

- 对于“归类”方法而言，多继承是非常自然的事情。如C++
- 而采用“分类”思想的计算机语言，则是单继承结构。并且会有一个基类Object。

JavaScript的Class比较接近**分类**的思想，但是也不完全是分类的思想，JavaScript其实是一个多范式的面向对象的语言

#### Object — Prototype

JavaScript描述对象的方式是基于原型，原型是一种更接近人类原始认知的描述对象的方法，它并不试图做严谨的分类，而是采用“相似”这样的方式区描述对象。任何对象仅仅需要描述它自己与原型的区别即可。JavaScript中所有对象的最终的原型为Object，而Object的原型为null。原型的选择比较灵活。 

#### 练习：用JavaScript采用面向对象的方式描述“狗咬人”。

- 对象的行为指的是改变对象状态的行为，而"狗咬人"改变的是人的状态，使人从正常状态变为负伤状态，所以用面向对象的方式描述“狗咬人”的时候，不应该把“咬人”这个行为定义在**狗**这个对象上，而应该在人这个对象上体现，但是注意不应该在人身上定义“被狗咬”这个行为，而是应该定义改变受伤状态的行为。
- 使用面向对象描述对象的时候不应该受到语言描述的干扰。在设计对象的状态和行为时，总是要遵循“行为改变状态”的原则。

#### Object in JavaScript

在JavaScrirpt运行时，原生对象的描述方式非常简单，至于要关心**原型**和**属性**两个部分。

JavaScript每个对象都有一个prototype，在JavaScript中，对象的属性既可以描述状态，也可以用来描述行为，因为JavaScript的函数也是可以放进属性里面的。

JavaScript对象的唯一标识性用内存地址，JavaScript里面原生支持了一个原型机制，当去找一个对象的属性的时候，如果它自身不包含属性，那么它就会到原型上去找，如果还是没有找到并且它的原型的原型不是null的话，还会继续往它的原型的原型上去找，这样就形成了一个链式的行为，所以往往会把JavaScript里面的原型描述为原型链，正式因为JavaScript获取属性的行为会沿着原型的指向一路向上找过去，一直找到原型为Nihilo（JavaScript中也就是null）这样的一个原型对象。

##### JavaScript属性

JavaScript属性是一个kv对，特点是可以根据k找到这个v，JavaScript属性的k值可以是两种类型：

- Symbol
- String

##### JavaScript属性的值

JavaScript用属性来统一抽象对象状态和行为。JavaScript对象属性的值有两种：

- 数据属性：用于描述状态
  - value：改特征值对应的值。可以是任何有效的JavaScript值（数值，对象，函数等）。默认是undefined
  - writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。
  - enumerable：定义了对象属性是否可以在for-in循环和Object.keys()等中被枚举
  - configurable：标识对象的属性是否可以被删除，以及除了value和writable特性外的其他特性能否被修改。
- 访问器属性：用于描述行为（数据属性中如果存储函数，也可以用于描述行为）
  - get：一个给属性提供getter的方法，如果没有getter则为undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里this并不一定是定义该属性的对象）。默认为undefined
  - set：一个给属性提供setter的方法，如果没有setter则为undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为undefined。
  - enumerable：同数据属性
  - configurable：同数据属性

##### JavaScript的原型机制

当访问属性时（特指点运算符访问属性），如果当前对象没有，则会沿着原型找到原型对象时否有此名称的属性，而原型对象还可能有原型，因此，会有“原型链”这一说法。

这一算法保证了，每个对象只需要描述自己和原型的区别即可。

##### Object API/Grammar

- {} . [] Object.defineProperty     这一组提供了一个基本的对象机制，能够通过语法区创建对象，访问属性和定义新的属性以及区改变属性的特征值，这个是基本的面向对象能力
- Object.create / Object.setPrototypeOf / Object.getPrototypeOf    这一组是基于原型的描述对象的方法，可以通过Object.create在指定原型的前提下创建对象，又可以去修改一个对象的原型或者获取一个对象的原型，这组可以叫基于原型的对象API
- new / class /extends   这一组新的语法结构是用来以基于分类的方式区描述对象，而这种基于分类的方式尽管在运行时仍然会被转换成JavaScript的原型相关的访问，但是从语法上来看，从抽象能力上来看，它完全是一个基于类的面向对象的组织方式
- new / function / prototype   这一组不建议使用

##### Function Object

JavaScript中有一些特殊的对象，比如函数对象，除了一般对象的属性和原型，函数对象还有一个行为[[call]]。用JavaScript中的function关键字、箭头运算符或者Function构造器创建的对象，会有[[call]]这个行为。用类似f()这样的语法把对象当作函数调用时，会访问到[[call]]这个行为。如果对应的对象没有[[call]]行为，则会报错。

**PS:凡是使用双括号([[call]])来定义的都是对象的一个内置的行为，在JavaScript代码中无论通过任何的方式都没有办法去访问到它，但是在开发JavaScript引擎的C++代码或者c代码中都是可以随便去实现和随便去调用的**

##### Host Object

Host Object在JavaScript语言标准中没有定义，是由宿主环境定义的，比如在浏览器里可以访问到window、setTimeout，这些都跟JavaScript的原生没有任何的关系，原生的Host Object可以去实现一些JavaScript语言里面并不支持，但是JavaScript语法支持的一些特性。