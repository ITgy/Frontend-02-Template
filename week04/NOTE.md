[TOC]

# week 4

## 浏览器工作原理总论

浏览器完成整体渲染需要以下5个步骤：

- 通过一个HTTP请求，解析HTTP回应，把URL里面包含的HTML取出来
- 对取出的文本的HTML进行parse，生成DOM树
- 进行CSS computing，得到带CSS属性的DOM树
- layout，通过布局和排版把DOM树上面的所有元素产生的盒的位置计算出来。
- render 渲染

经过以上5步，就从一个URL得到了一个Bitmap。

## 有限状态机

### 什么是有限状态机？

有限状态机，英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：**状态（State）、事件（Event）、动作（Action）**。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。

> **举例说明：**
>
> 在《超级马里奥》游戏中，马里奥可以变身为多种形态，比如小马里奥(Small Mario)、超级马里奥(Super Mario)、火焰马里奥(Fire Mario)、斗篷马里奥(Cape Mario)等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。
>
> 在这里面:
>
> - 状态（State）：马里奥的不同形态就是状态机中的“状态”。
> - 事件（Event）：游戏情节（比如吃了蘑菇）就是状态机中的“事件”。
> - 动作（Action）：加减积分就是状态机中的动作。
>
> **吃蘑菇这个事件，会触发状态的转移（从小马里奥转移到超级马里奥），以及触发动作的执行（增加100积分）。**

### 状态机的实现方式

- **分支逻辑法**

  参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的if-else或switch-case分支判断逻辑，甚至是嵌套的分支判断逻辑。

- **查表法**

  状态机用一个二维表来表示，如下所示：

  |       | E1(Got MushRoom) | E2(Got Cape) | E3(Got Fire Flower) | E4(Met Monster) |
  | :---: | :--------------: | :----------: | :-----------------: | :-------------: |
  | Small |    Super/+100    |  Cape/+200   |      Fire/+300      |        /        |
  | Super |        /         |  Cape/+200   |      Fire/+300      |   Small/-100    |
  | Cape  |        /         |      /       |          /          |   Small/-200    |
  | Fire  |        /         |      /       |          /          |   Small/-300    |

  **备注：**表中的斜杠表示不存在这种状态转移。

  在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到新的状态及其执行的动作。

- **状态模式**

  状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。

### 有限状态机描述

- 每一个状态都是一个机器
  - 在每一个机器里，可以做计算、存储、输出。。。
  - 所有的这些机器接受的输入是一致的
  - 状态机的每一个机器本身没有状态，如果用函数表示的话，它应该是纯函数（无副作用）
- 每一个机器知道下一个状态
  - 每个机器都有确定的下一个状态（Moore）
  - 每个机器根据输入决定下一个状态（Mealy）

### JS中的有限状态机（Mealy）

```
//每个函数是一个状态
function state(input)//函数参数就是输入
{
	//在函数中，可以自由地编写代码，处理每个状态的逻辑
	return next; //返回值作为下一个状态
}


//以下是调用
while(input){
	//获取输入
	state = state(input);//把状态机的返回值作为下一个状态
}
```

## 浏览器从发送请求到页面呈现的流程

URL(HTTP) —> HTML(parse) —> DOM(CSS computing) —> DOM with CSS(layout) —> DOM with position(render) —> Bitmap

## HTTP的协议解析

### ISO-OSI七层网络模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

以上七层网络模型可按如下划分：

- HTTP（require("http")）
  - 应用层
  - 表示层
  - 会话层
- TCP（require("net")）
  - 传输层
- Internet
  - 网络层
- 4G/5G/Wi-Fi：以下两层主要完成的目标是对数据的一个准确的传输，这个传输是一个点对点的传输，就是说必须要这两个东西有一个直接的连接，才能够进行传输
  - 数据链路
  - 物理层

### TCP与IP的基础知识

- TCP
  - 流
  - 端口
  - require('net')

- IP
  - 包
  - IP地址
  - libnet/libpcap

### HTTP

- Request
- Response

### 实现toy_browser

#### HTTP请求

- 第一步 HTTP请求
  - 设计一个HTTP请求到的类
  - content-type是一个必要的字段，要有默认值
  - body是KV格式
  - 不同content-type影响body的格式
- 第二步 send函数
  - 在Request的构造器中收集必要的信息
  - 设计一个send函数，把请求真实发送到服务器
  - send函数应该是异步的，所以返回Promise
- 第三步 发送请求
  - 设计支持已有的connection或者自己新建connection
  - 收到数据传给parser
  - 根据parser的状态resolve Promise
- 第四步 ResponseParser
  - Response必须分段构造，所以要用一个ResponseParser来“装配”
  - ResponseParser分段处理ResponseText，用状态机来分析文本的结构
- 第五步 BodyParser
  - Response的body可能根据Content-Type有不同的结构，因此会采用子Parser的结构来解决问题
  - 以TrunkedBodyParser为例，同样用状态机来处理body的格式

#### HTML解析

- 第一步 parser模块的文件拆分

  - 为了方便文件管理，把parser单独拆到文件中
  - parser接收HTML文本作为参数，返回一颗DOM树
- 第二步 用FSM实现HTML的分析

  - 用FSM来实现HTML的分析
  - 在HTML标准中，已经规定了HTML的状态
  - Toy-Browser只挑选其中一部分状态，完成一个最简版本
- 第三步 HTML解析
  - HTML里面的tag(标签)大概有3种：1. 开始标签 2. 结束标签 3. 自封闭标签、
  - 在这一步暂时忽略属性
- 第四步 创建元素
  - 在状态机中，除了状态迁移，还会要加入业务逻辑
  - 在标签结束状态提交标签token
- 第五步 处理属性
  - 属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理
  - 处理属性的方式跟标签类似
  - 当属性结束时，把属性加到标签Token上
- 第六步 用token构建DOM树
  - 从标签构建DOM树的基本技巧是使用栈
  - 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
  - 自封闭节点可视为入栈后立刻出栈
  - 任何元素的父元素是它入栈前的栈顶
- 第七步 将文本节点加到DOM树
  - 文本节点与自封闭标签处理类似
  - 多个文本节点需要合并